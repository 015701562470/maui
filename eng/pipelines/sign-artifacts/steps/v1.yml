####################################################################################################
# SIGN AZURE DEVOPS ARTIFACTS
#
# This template will request a signing job for the current (or requested) build and then download
# the artifacts to the requested target folder.
#
# Currently, the prerequisites are:
#  1. run "PublishBuildArtifacts" with "artifactName: nuget"
#
# Typical usage is:
#
#  resources:
#    repositories:
#      - repository: xamarin-templates
#        type: github
#        name: xamarin/yaml-templates
#        endpoint: <name of service connection to use to access github.com>
#
#  ...
#
#  jobs:
#    - job: <job-name>
#      pool:
#        name: VSEng-XamarinCustom
#        demands:
#          - corpnet
#      steps:
#        - template: sign-artifacts/steps/v1.yml@xamarin-templates
#          parameters:
#            targetFolder: $(Build.ArtifactStagingDirectory)/signed
#
####################################################################################################

parameters:
  targetFolder: '$(Build.ArtifactStagingDirectory)/signed'  # The folder to download the signed artifacts to            # eg: $(Build.ArtifactStagingDirectory)/signed
  sourceRepo: '$(Build.Repository.Name)'                    # The repository that this build is trying to sign          # typically: $(BUILD_REPOSITORY_NAME)
  jenkinsEndpoint: '$(Signing.Endpoint)'                    # The endpoint name for the Jenkins server                  # typically: Xamarin Code Signing Jenkins
  jenkinsJob: '$(Signing.Job)'                              # The definition of the build to use to get the artifacts   # typically: sign-from-vsts
  artifactHost: '$(Signing.ArtifactHost)'                   # The host for the signing artifacts                        # typically: https://dl.internalx.com/vsts-devdiv
  githubToken: '$(GitHub.Token)'                            # The GitHub token to use to access the signed artifacts    # typically: <use any PAT that has access>
  CodeSignOverride: ''                                      # 'true' -- enable RealSigning, 'false' -- disable Realsigning, '' -- let the pipeline decide

steps:
  - powershell: |
      $codeSignOverride = "${{ parameters.CodeSignOverride }}"
      Write-Host "codeSignOverride: ${codeSignOverride}"

      $branch = '$(Build.SourceBranch)'
      $reason = '$(Build.Reason)'

      $signType = 'Test'
      if ($codeSignOverride -eq 'true') {
        $signType = 'Real'
      } elseif ([string]::IsNullOrWhiteSpace($codeSignOverride)) {
        $branchCheck = ($branch -eq 'refs/heads/main') -or ($branch -eq 'refs/heads/master')
        if ($branchCheck -and ($reason -ne 'PullRequest')) {
          $signType = 'Real'
        }
      }

      if ([string]::IsNullOrWhiteSpace($signType) -or ($signType -ne 'Real' -and $signType -ne 'Test')) {
          Write-Host "ERROR: signType parameter set to an unexpected value '${signType}'. Expected 'Real' or 'Test'"
          exit 1
      } else {
        Write-Host "SUCCESS: signType is set to '${signType}'"
        Write-Host "##vso[task.setvariable variable=Xamarin.SignType;]$signType"
      }
    displayName: 'CodeSign: Determine SignType'

  - powershell: |
      Write-Host "##vso[task.setvariable variable=RepoName;]${{ coalesce(parameters.sourceRepo, '$(Build.Repository.Name)') }}
    displayName: 'Set coalesced repo name variable'

  - powershell: |
      Write-Host "REPO: $(RepoName)"
      Write-Host "COMMIT: $(Build.SourceVersion)"
      Write-Host "JOB_ID: $(System.DefinitionId)"
      Write-Host "BUILD_ID: $(Build.BuildId)"
      Write-Host "SIGN_TYPE: $(Xamarin.SignType)"
      Write-Host "BUILD_NUMBER: $(Build.BuildNumber)"
      Write-Host "BUILD_URI: $(Build.BuildUri)"
    displayName: 'Show signing parameters'

  # https://github.com/huserben/TfsExtensions/blob/master/BuildTasks/overview.md
  - task: benjhuser.tfs-extensions-build-tasks.trigger-build-task.TriggerBuild@3
    displayName: 'Request Artifact Signing'
    inputs:
      buildDefinition: ${{ parameters.jenkinsJob }}       # Typically sign-from-vsts: https://devdiv.visualstudio.com/DevDiv/_build?definitionId=13913
      useSameSourceVersion: false
      useSameBranch: false
      branchToUse: 'full-esrp-integration'
      waitForQueuedBuildsToFinish: true
      storeInEnvironmentVariable: true
      buildParameters: '{ "REPO": "$(RepoName)", "COMMIT": "$(Build.SourceVersion)", "JOB_ID": "$(System.DefinitionId)", "BUILD_ID": "$(Build.BuildId)", "SIGN_TYPE": "$(Xamarin.SignType)", "BUILD_NUMBER": "$(Build.BuildNumber)", "BUILD_URI": "$(Build.BuildUri)" }'
      authenticationMethod: 'OAuth Token'
      password: $(System.AccessToken)     # Equivalent to the 'Allow scripts to access OAuth token option': https://stackoverflow.com/questions/52837980/how-to-allow-scripts-to-access-oauth-token-from-yaml-builds

  - powershell: |
      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

      Function Dump-Host {
        [cmdletbinding()]
        Param(
          $Message,
          [parameter(ValueFromPipeline)]$Data)
        Process {
          $_ = $Data
          if ($Message) {
            $Message = $ExecutionContext.InvokeCommand.ExpandString($Message)
            Write-Host $Message
          } else {
            Write-Host $Data
          }
          $Data
        }
      }

      $targetRoot = "${{ parameters.targetFolder }}"
      $jobId = "$(System.DefinitionId)"
      $buildId = "$(Build.BuildId)"
      $token = "${{ parameters.githubToken }}"
      $url = "${{ parameters.artifactHost }}/$jobId-$buildId/metadata.json"

      Write-Host "Getting manifest from $url"
      $manifest = [string](Invoke-WebRequest -Uri $url -UseBasicParsing -Headers @{"Authorization"="token $token"}) | Dump-Host | ConvertFrom-Json

      if (!(Test-Path $targetRoot -PathType Container)) {
        New-Item -ItemType Directory -Force -Path $targetRoot
      }

      foreach ($file in $manifest) {
        $fileUrl = $file.url
        $fileName = [IO.Path]::GetFileName($fileUrl)
        Write-Host "Downloading artifact to $targetRoot/$fileName"
        Invoke-WebRequest -Uri $fileUrl -Headers @{"Authorization"="token $token"} -OutFile "$targetRoot/$fileName"
      }
    displayName: 'Download Signed Artifacts'
