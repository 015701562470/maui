####################################################################################################
# SIGN AZURE DEVOPS ARTIFACTS
#
# This template will request a signing job for the current (or requested) build and then download
# the artifacts to the requested target folder.
#
# Currently, the prerequisites are:
#  1. run "PublishBuildArtifacts" with "artifactName: nuget"
#
# Typical usage is:
#
#  resources:
#    repositories:
#      - repository: xamarin-templates
#        type: github
#        name: xamarin/yaml-templates
#        endpoint: <name of service connection to use to access github.com>
#
#  ...
#
#  jobs:
#    - job: <job-name>
#      pool:
#        name: VSEng-XamarinCustom
#        demands:
#          - corpnet
#      steps:
#        - template: sign-artifacts/steps/v1.yml@xamarin-templates
#          parameters:
#            targetFolder: $(Build.ArtifactStagingDirectory)/signed
#
####################################################################################################

parameters:
  targetFolder: '$(Build.ArtifactStagingDirectory)/signed'  # The folder to download the signed artifacts to            # eg: $(Build.ArtifactStagingDirectory)/signed
  sourceRepo: '$(Build.Repository.Name)'                    # The repository that this build is trying to sign          # typically: $(BUILD_REPOSITORY_NAME)
  jenkinsEndpoint: '$(Signing.Endpoint)'                    # The endpoint name for the Jenkins server                  # typically: Xamarin Code Signing Jenkins
  jenkinsJob: '$(Signing.Job)'                              # The definition of the build to use to get the artifacts   # typically: sign-from-vsts
  artifactHost: '$(Signing.ArtifactHost)'                   # The host for the signing artifacts                        # typically: https://dl.internalx.com/vsts-devdiv
  githubToken: '$(GitHub.Token)'                            # The GitHub token to use to access the signed artifacts    # typically: <use any PAT that has access>
  CodeSignOverride: ''                                      # 'true' -- enable RealSigning, 'false' -- disable Realsigning, '' -- let the pipeline decide

steps:
  - powershell: |
      $codeSignOverride = "${{ parameters.CodeSignOverride }}"
      Write-Host "codeSignOverride: ${codeSignOverride}"

      $branch = '$(Build.SourceBranch)'
      $reason = '$(Build.Reason)'

      $signType = 'Test'
      if ($codeSignOverride -eq 'true') {
        $signType = 'Real'
      } elseif ([string]::IsNullOrWhiteSpace($codeSignOverride)) {
        $branchCheck = ($branch -eq 'refs/heads/main') -or ($branch -eq 'refs/heads/master')
        if ($branchCheck -and ($reason -ne 'PullRequest')) {
          $signType = 'Real'
        }
      }

      if ([string]::IsNullOrWhiteSpace($signType) -or ($signType -ne 'Real' -and $signType -ne 'Test')) {
          Write-Host "ERROR: signType parameter set to an unexpected value '${signType}'. Expected 'Real' or 'Test'"
          exit 1
      } else {
        Write-Host "SUCCESS: signType is set to '${signType}'"
        Write-Host "##vso[task.setvariable variable=Xamarin.SignType;]$signType"
      }
    displayName: 'CodeSign: Determine SignType'

  - task: JenkinsQueueJob@2
    displayName: 'Request Artifact Signing'
    inputs:
      serverEndpoint: ${{ parameters.jenkinsEndpoint }}
      jobName: ${{ parameters.jenkinsJob }}
      isParameterizedJob: true
      jobParameters: |
        REPO=${{ coalesce(parameters.sourceRepo, '$(Build.Repository.Name)') }}
        COMMIT=$(Build.SourceVersion)
        JOB_ID=$(System.DefinitionId)
        BUILD_ID=$(Build.BuildId)
        SIGN_TYPE=$(Xamarin.SignType)

  - powershell: |
      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

      Function Dump-Host {
        [cmdletbinding()]
        Param(
          $Message,
          [parameter(ValueFromPipeline)]$Data)
        Process {
          $_ = $Data
          if ($Message) {
            $Message = $ExecutionContext.InvokeCommand.ExpandString($Message)
            Write-Host $Message
          } else {
            Write-Host $Data
          }
          $Data
        }
      }

      $targetRoot = "${{ parameters.targetFolder }}"
      $jobId = "$(System.DefinitionId)"
      $buildId = "$(Build.BuildId)"
      $token = "${{ parameters.githubToken }}"
      $url = "${{ parameters.artifactHost }}/$jobId-$buildId/metadata.json"

      Write-Host "Getting manifest from $url"
      $manifest = [string](Invoke-WebRequest -Uri $url -UseBasicParsing -Headers @{"Authorization"="token $token"}) | Dump-Host | ConvertFrom-Json

      if (!(Test-Path $targetRoot -PathType Container)) {
        New-Item -ItemType Directory -Force -Path $targetRoot
      }

      foreach ($file in $manifest) {
        $fileUrl = $file.url
        $fileName = [IO.Path]::GetFileName($fileUrl)
        Write-Host "Downloading artifact to $targetRoot/$fileName"
        Invoke-WebRequest -Uri $fileUrl -Headers @{"Authorization"="token $token"} -OutFile "$targetRoot/$fileName"
      }
    displayName: 'Download Signed Artifacts'
